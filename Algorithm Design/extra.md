# 线段树
支持解决的问题
- 区间查询，修改，维护
- 复杂度 $O(\log n)$ （平衡二叉树）
> 区间求和、最值等

不支持的问题
- 区间覆盖，区间添加
> 区间众数，区间最长连续问题、最长不下降问题等
## 基本思想
```
                   [l, r]
                  /       \
          [l, mid]         [mid+1, r]
         /      \            /       \
[l, mid1] [mid1+1, mid] [mid+1, mid2] [mid2+1, r]
```

## Lazy 标记
- 如果更新完全覆盖当前区间，更新该区间并 lazy 标记
- 否则先下传 lazy 标记，再分别搜索左右儿子，最后更新当前区间
- (即下传停止在 lazy 处)

# KMP
设 $s$ 是全字符串，$s_0$ 是一个待匹配子串
> 暴力做法：$O(nm)$
> $$s[i:i+j] == s_0[:j]$$
> $i,j$ 同时回溯，i++, j = 0

### What is it Missing?
假设在 $s[i: i+j], s_0[:j]$ 处 break，那么之前的都*macth*了。


由于 $s[i: i+j] = s_0[:j]$, 暨求 $s_0[:j]$ 的部分匹配，

于是，下一次 $i$ 的位置是 $s[i+1:i+j]$ 的后缀第一次成功与 $s_0[:j]$ 的前缀匹配的位置。暨 $s_0[:j]$ 后往前，最长能与 $s_0[:j]$ 前缀匹配的位置
- $i' = i + (j - next[j])$
- $j = j - (j - next[j]) = next[j]$


可以通过`预计算` $s_0$ 的 `next` 数组，即可在 $O(n)$ 时间内完成匹配

## next 数组
next 数组的含义是：对于字串 $s_0[:j]$，最长的、前缀后缀匹配的长度

于是，对于 $next[j+1]$($s_0[:j+1]$) 和 $next[j]$($s_0[:j]$) 的传递，有：
- 若 $s_0[j+1] == s_0[next[j]]$，则 $next[j+1] = next[j] + 1$
- 说明 $next[j+1] \leq next[j]$，更进一步，由于在 $next[j]$ 处已经匹配成功，$s_0[:next[j]] == s_0[j+1 - next[j] :j+1]$，于是递归地有
  ```
  next[j+1] = 
  (s_0[j+1] == s_0[next[next[j]]])? next[next[j]] + 1 : 
  (s_0[j+1] == s_0[next^3[j]]) ? next^3[j] + 1 :...
  ```

$O(n + m)$